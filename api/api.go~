package api

import (
	"context"
	"errors"
	"fmt"
	"math/rand"
	"net/http"
	"strings"
	"time"
	"url-shortner/auth"
	"url-shortner/utils"

	"github.com/jackc/pgconn"
	"github.com/jackc/pgx"
	"github.com/jackc/pgx/v4/pgxpool"
	"github.com/shikhar0507/requestJSON"
)

func init() {

}

type ReqURL struct {
	Url string `json: url`
}
type stop struct {
	error
}

func getResourceId(path string, sep string) (string, error) {
	linkid := strings.TrimPrefix(path, "/api/v1/link/")
	if linkid == path {
		return "", fmt.Errorf("%s", "No resource found")
	}
	return linkid, nil

}

func HandleCampaigns(w http.ResponseWriter, r *http.Request, db *pgxpool.Pool) {

}

// / GET , / POST
// /id/ GET ,DELETE , PUT
func HandleLinks(w http.ResponseWriter, r *http.Request, db *pgxpool.Pool) {
	username, _, err := auth.GetSession(r, db)
	if err != nil {
		switch err {
		case pgx.ErrNoRows:
			resp := utils.Response{Status: http.StatusUnauthorized, Message: "Unauthorized user"}
			utils.SendResponse(w, http.StatusUnauthorized, resp)
			break
		default:
			resp := utils.Response{Status: http.StatusInternalServerError, Message: "Try again later"}
			utils.SendResponse(w, http.StatusInternalServerError, resp)
		}
		return
	}

	resId, err := getResourceId(r.URL.Path, "/v1/links/")
	if err != nil {
		resp := utils.Response{Status: http.StatusNotFound, Message: err.Error()}
		utils.SendResponse(w, http.StatusNotFound, resp)
		return
	}

	if resId == "" {
		switch r.Method {
		case http.MethodGet:
			getLinks(w, r, db, username)
			break
		}
		return
	}

	switch r.Method {
	case http.MethodGet:
		getLink(w, r, db, resId)
		break
	case http.MethodDelete:
		break
	case http.MethodPut:
		break
	}

}

type Link struct {
	Browser      map[string]int `json:browser`
	Os           map[string]int `json:os`
	Device_type  map[string]int `json:device_type`
	Total_clicks int            `json:total_clicks`
}

type Links struct {
	Result []map[string]interface{} `json:result`
}

func getLink(w http.ResponseWriter, r *http.Request, db *pgxpool.Pool, resId string) {
	query := `select browser,browser_count,os,os_count,device_type,device_count,t0.total_clicks from (select id,count(*) as total_clicks from logs where id='$1' group by id)t0 full outer join  (select browser,count(*) as browser_count,row_number () over() as num from logs where id='$1' group by browser order by browser_count desc) t1 on 1=1
left join                                                                                                              
(select os,count(*) as os_count, row_number() over() as num from logs where id='$1'  group by os order by os_count desc) t2 on t1.num = t2.num                                                                                                   
left join 
(select device_type,count(*) as device_count , row_number() over() as num from logs where id='$1' group by device_type order by device_count desc)t3 on t2.num = t3.num`
	rows, err := db.Query(context.Background(), query, resId)
	if err != nil {
		utils.SendResponse(w, http.StatusInternalServerError, utils.Response{Status: http.StatusInternalServerError, Message: "Try again later"})
		return
	}
	var link Link
	for rows.Next() {
		var browser, os, device_type string
		var browserC, osC, device_typeC, total_clicks int32
		rows.Scan(&browser, &browserC, &os, &osC, &device_type, &device_typeC, &total_clicks)
		link.Browser[browser] = int(browserC)
		link.Os[os] = int(osC)
		link.Device_type[device_type] = int(device_typeC)
		link.Total_clicks = int(total_clicks)
	}
	utils.SendResponse(w, http.StatusOK, link)
}

func getLinks(w http.ResponseWriter, r *http.Request, db *pgxpool.Pool, username string) {

	query := `with t as (
select urls.id,t2.device_type,t1.browser,t0.os,t4.total_clicks,sum(case when t4.total_clicks is not null then t4.total_clicks else 0 end) from urls
left join (select id,count(*) as total_clicks from logs group by id order by total_clicks desc)t4 on t4.id = urls.id
left join (select t.* from (select logs.id,logs.device_type, rank() over(partition by id order by count(device_type) desc) from logs group by logs.id,logs.device_type) t where rank=1)t2 on urls.id = t2.id
left join (select t.* from (select logs.id,logs.browser, rank() over(partition by id order by count(browser) desc) from logs group by logs.id,logs.browser) t where rank=1) t1 on t2.id = t1.id
left join  (select t.* from (select logs.id,logs.os, rank() over(partition by id order by count(os) desc) from logs group by logs.id,logs.os) t where rank=1)t0 on t1.id = t0.id where urls.id='$1'  group by urls.id,t2.device_type,t1.browser,t0.os,t4.total_clicks
order by sum desc)
select t.id,t.username,t.browser,t.os,t.device_type,t.total_clicks from t`

	rows, err := db.Query(context.Background(), query, username)
	if err != nil {
		utils.SendResponse(w, http.StatusInternalServerError, utils.Response{Status: http.StatusInternalServerError, Message: "Try again later"})
		return
	}
	list := make([]map[string]interface{}, 1)
	for rows.Next() {
		var id, device_type, browser, os, username string
		var total_clicks int
		var hash map[string]interface{}
		rows.Scan(&id, username, browser, os, device_type, total_clicks)
		hash["id"] = id
		hash["username"] = username
		hash["browser"] = browser
		hash["os"] = os
		hash["device_type"] = device_type
		hash["total_clicks"] = total_clicks
		list = append(list, hash)
	}
	links := Links{Result: list}
	utils.SendResponse(w, http.StatusOK, links)
}

/*
func handleCampaign(w http.ResponseWriter, r *http.Request) {
	optns := utils.HandleCors(w, r, http.MethodPost)
	if optns == true {
		return
	}


	result := requestJSON.Decode(w, r, &bod)
	if result.Status != 200 {
		utils.SendResponse(w, result.Status, result)
		return
	}
	if bod.Campaign == "" {
		resp := utils.Response{Status: http.StatusBadRequest, Message: "Campaign name cannot be empty"}
		utils.SendResponse(w, http.StatusBadRequest, resp)
		return
	}

	_, err := setId(r, bod.ReqURL.Url)
	if err != nil {
		fmt.Println(err)
		if err.Error() == "failed to assign a unique value" {
			resp := utils.Response{Status: http.StatusInternalServerError, Message: err.Error()}
			utils.SendResponse(w, http.StatusInternalServerError, resp)
			return
		}
		resp := utils.Response{Status: http.StatusInternalServerError}
		utils.SendResponse(w, http.StatusInternalServerError, resp)
		return
	}
	resp := utils.Response{Status: http.StatusOK, Message: "campaign created"}
	utils.SendResponse(w, http.StatusOK, resp)
}
*/
func handleShortner(w http.ResponseWriter, r *http.Request, db *pgxpool.Pool) {

	optns := utils.HandleCors(w, r, []string{"http.MethodPost"})
	if optns == true {
		return
	}

	var reqURL ReqURL

	result := requestJSON.Decode(w, r, &reqURL)

	if result.Status != 200 {

		utils.SendResponse(w, result.Status, result)
		return
	}

	id, err := setId(r, reqURL.Url, db)
	if err != nil {
		fmt.Println(err)
		if err.Error() == "failed to assign a unique value" {
			resp := utils.Response{Status: http.StatusInternalServerError, Message: err.Error()}
			utils.SendResponse(w, http.StatusInternalServerError, resp)
			return
		}
		resp := utils.Response{Status: http.StatusInternalServerError}
		utils.SendResponse(w, http.StatusInternalServerError, resp)
	}
	fmt.Println("used id", id)

	succ := utils.SuccesRes{Status: 200, Url: "http://localhost:8080/" + id}
	utils.SendResponse(w, 200, succ)

}

func setId(r *http.Request, largeUrl string, db *pgxpool.Pool) (string, error) {
	value := createId()
	mainErr := retry(100, 1000, func() error {

		username, _, err := auth.GetSession(r, db)
		_, err = db.Exec(context.Background(), "insert into urls values($1,$2,$3)", value, largeUrl, username)
		if err == nil {
			return nil

		}
		var pgErr *pgconn.PgError
		if errors.As(err, &pgErr) {
			switch pgErr.Code {
			case "23505":
				fmt.Println("creating a new id")
				value = createId()
				return err
			}
		}
		return err
	})

	if mainErr != nil {
		return "", mainErr
	}
	return value, nil

}

func retry(count int, sleep time.Duration, f func() error) error {
	err := f()
	if err != nil {
		if s, ok := err.(stop); ok {
			return s.error
		}
		count--
		if count > 0 {
			time.Sleep(sleep)
			return retry(count, 1*sleep, f)
		}
		return err
	}
	return nil
}

func createId() string {
	letterString := []byte("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
	result := ""

	for i := 0; i < 6; i++ {
		randStr := letterString[rand.Intn(len(letterString))]
		result = result + string(randStr)
	}
	return result
}
